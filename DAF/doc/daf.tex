\documentclass[preprint]{revtex4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\newcommand{\rtpi}{\ensuremath{\sqrt{\pi}}}
\newcommand{\intl}{\int\displaylimits}
\newcommand{\intunit}{\ensuremath{\int_{-1}^{1}}}
\newcommand{\sumunit}{\ensuremath{\sum_{i=1}^{n}}}
\newcommand{\dx}{{\rm d}x}
\newcommand{\dy}{{\rm d}y}
\newcommand{\wbar}{\ensuremath{\bar{w}}}
\newcommand{\Xray}{\ensuremath{\bf{x}}}
\newcommand{\Xbar}{\ensuremath{\bf{\bar{x}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{%
    Distributed Approximating Functionals\\
    {\small Theory and Computational Methodology}\\
}
\author{Daniel A. Brue}
\date{\today}

\begin{abstract}
The abstract goes here after the paper is done.
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The distributed approximating functionals (DAF) method was developed 
and implemented for solving classes of differential equations very accurately
with a high fidelity to the accuracy of derivatives. 
The DAF method was applied first to time-dependent propgation problems in theoretical
quantum physics applications\cite{Kouri-DAF1,Kouri-DAF2,Kouri-DAF3,Kouri-DAF4,
Kouri-DAF5,Kouri-DAF6,Kouri-DAF7}.

The DAF method has been used in various situations that involve time evolution, 
from quantum particle trajectories\cite{QTM}, integration of Feynman path integrals\cite{DAF-Szalay1},
and fluid dynamics\cite{NVS,Burgers}, and also as a method of solving bound eigenvalue-eigenvector
problems\cite{DAF-Szalay2,SGWD} and data interpolation\cite{DAF-Szalay3}.

The DAF method is more computationally intensive in practice than other simpler methods, 
however, much can be precomputed and reused, so the most time consuming aspects of the
method need be computed only once 

\begin{enumerate}
\item{\bf Differential Equations}: The DAF method constructs matrix operators that
	can be applied to multidimentional linear differential equations. 
\item{\bf Interpolation}: The DAF method can be used to approximate functions and
	their derivatives with high accuracy. 
\end{enumerate}

%-----------------------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Backgound}
In this section, we develop the mathematical foundation for the DAF method, establish 
the needed relations to employ the DAF in practice, and define its limitations. 

%-----------------------------------------------------------------------------------------
\subsection{Hermite Expansion of Delta Functions}
The DAF method uses an approximation of the Dirac delta function generated by 
an expansion in Hermite polynomials. With the appropriate Gaussian weight function, 
the Hermite polynomials form a complete and orthogonal basis on the domain of 
$(-\infty,\infty)$. 
This basis set can be used to expand any function on this domain. The advantages
of this method include high degrees of accuracy in representing other functions, 
and provides an analytic, functional approximation of undefined functions such as 
what might be represented by discrete data points. 

The expansion follows the general formula\cite{HermiteWiki} of 
\begin{equation}
\label{eqn_deltaHexp0}
\delta(x) = \sum_{m=0}^\infty h_m H_m\left(\frac{x}{\sigma}\right) e^{-\left(\frac{x}{\sigma}\right)}
\end{equation}
Where $H_m$ are the Hermite polynomials, $\sigma$ is a scaling function, and $h_m$ are the
expansion coefficients. A few notes on these terms: 
\begin{itemize}
\item{$H_m(x)$}: There are two common definitions for the Hermite polynomials, which are referred
to commonly as the {\it probability} and the {\it physics} definitions, which here we follow
Wikipedia's notation and use $H_m$ for the physics definition and ${\it He}_m$ for the probabilistic. 
They are related by ${\it He}_m = 2^m H_m$. In this document, we use the physics definition. 
\item{$\sigma$}: The scaling function $\sigma$ can be used to scale the Hermite functions 
``horizontally''. In the practical case in which the infinite sum in equation \ref{eqn_deltaHexp0}
is limited to a finite number of terms, the $\sigma$ factor directly effects how many terms
are needed to represent a function. 
A poorly chosen value of $\sigma$ can make converging the summation very difficult. 

\item{$h_m$}: The expansion coefficients represent how much each Hermite term contributes to the
expansion. These can be derived analytically for the $\delta(x)$ expansion.
This derivation is shown below. 
\end{itemize}

To determine the expansion coefficients $h_m$, we begin with equation \ref{eqn_deltaHexp0}
and multiply each side by $H_n(x/\sigma)$ and integrate over $(-\infty,\infty)$, 
\begin{eqnarray}
\label{eqn_deltaHexp1}
\intl_{-\infty}^{\infty}H_n\left(\frac{x}{\sigma}\right)\delta(x)dx & = & 
 \intl_{-\infty}^{\infty}H_n\left(\frac{x}{\sigma}\right)\sum_{m=0}^\infty h_m H_m\left(\frac{x}{\sigma}\right) e^{-\left(\frac{x}{\sigma}\right)} dx \\*
H_n(0) & = & 
\sum_{m=0}^\infty h_m \intl_{-\infty}^{\infty}H_n\left(\frac{x}{\sigma}\right)
H_m\left(\frac{x}{\sigma}\right) e^{-\left(\frac{x}{\sigma}\right)} dx 
\label{eqn_deltaHexp2}
\end{eqnarray}
Next we use the orthogonality property\cite{HermiteWiki,HermitePolyMW} of 
\begin{equation}
\label{eqn_Hortho}
\intl_{-\infty}^{\infty}H_m(x)H_n(x)e^{-x^2}dx = \rtpi\, 2^m m!\, \delta_{mn}
\end{equation}
where $\delta_{mn}$ is the Kronecker Delta function and is equal to $1$ if $m=n$ and $0$ otherwise. 
With a scaling factor, $\sigma$, this becomes
\begin{equation}
\label{eqn_Hortho1}
%\intl_{-\infty}^{\infty}H_m\left(\frac{x}{\sigma}x\right)H_n\left(\frac{x}{\sigma}\right)e^{-\left(\frac{x}{\sigma}x\right)^2dx = \rtpi 2^m m! \delta_{mn}
\intl_{-\infty}^{\infty} H_m\left(\frac{x}{\sigma}\right) H_n\left(\frac{x}{\sigma}\right) 
e^{-\left(\frac{x}{\sigma}\right)^2}dx = 
\sigma \rtpi\, 2^m m!\, \delta_{mn}
\end{equation}

Using this in equation \ref{eqn_deltaHexp2}, we have

\begin{equation*}
H_n(0)  =  \sum_{m=0}^\infty h_m \sigma \rtpi\, 2^m m!\, \delta_{mn} \nonumber
\end{equation*}
which gives
\begin{equation}
h_n = \frac{H_n(0)}{\sigma \rtpi \, 2^n \, n!}
\label{eqn_deltaHexp_hn}
\end{equation}
One thing that can be observed by this definition is that for all odd values of $n$, the
coefficient $h_n$ is zero because $H_n(0)=0$ for all odd-order Hermite polynomials. 
This makes sense when we consider that the Dirac delta function is symmetric in $x$, and
therefore only even Hermite functions, i.e. those that are also symmetric in $x$, will
contribute to the expansion series. 

Note that we can use the Hermite polynomial recurrsion relation, given as
\begin{equation}
\label{eqn_HermiteRecur}
H_{n+1}(x) = 2xH_n(x)-2nH_{n-1}(x)
\end{equation}
to quickly find the coefficients. We can see that the first several $h_n$  are
\begin{eqnarray}
h_0 & =&  1 \nonumber \\
h_1 &=& 0 \nonumber \\
h_2 &=& 2*0*H_1(0)-2*1*H_0(0) = -2 \nonumber \\
h_3 &=& 0 \nonumber \\
h_4 &=& 2*0*H_3(0) - 2*3*-2= 12 \nonumber \\
&...& \nonumber
\end{eqnarray}

From this we define a function, $\Delta_{\sigma,M}(x)$ that depends parametrically on
$\sigma$ and $M$, and is exact as $M\to\infty$, 
\begin{equation}
\label{eqn_DeltaExpansion}
\Delta_{\sigma,M}(x) = \sum_{m=0}^M h_m H_m \left(\frac{x}{\sigma}\right)e^{- \left(\frac{x}{\sigma}\right)^2}
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Application}

Here we assess some test cases to show how the DAF method functions in practice. 
and with this function, we can approximate any function with
\begin{equation}
\label{eqn_f0delta_ident}
f(x) = \int f(y)\Delta_{\sigma,M}(y-x) {\rm d}y
\end{equation}
Note here also that taking the derivative with respect to $x$ in the above equation
gives
\begin{equation}
\label{eqn_f1delta_ident}
\frac{{\rm d}}{{\rm d}x}f(x) = 
    \int f(y) \frac{{\rm d}}{{\rm d}x}\left[\Delta_{\sigma,M}(y-x)\right] {\rm d}y
\end{equation}
where we note that on the right side, the derivative applies only to the $\Delta$ term. 
Since this is an expansion of polynomials and weight functions, the derivative is analytic. 

%-----------------------------------------------------------------------------------------
\subsection{One-Dimensional}
In a one-dimensional DAF application, we consider a continuous domain in $x$ from which
we have have discrete set of abscissas where we have samples of the function $f(x)$. 

The function $f(x)$ is known only at the set of discrete points $[x_n]$.
There are many methods to fit these data points to an analytic function so that it is
easier to work with. The DAF method has some advantages that make it very appealing
for some cases. 


Let's assume we have a set of coordinate points, $(x_0,f_0),(x_1,f_1),...$ that represent
some measured data or a given function. The set of $x$ values we will describe as ${\bf x}$
and we have
\begin{equation*}
f({\bf x}) = {\bf f}
\end{equation*}
where ${\bf x, f}$ are sets of discrete points, and any of these individual points will
be referenced as $x_i$, for example. 

Next we define another set of points along the $x$ axis. These are the points at which
we want values or derivatives for the function $f(x)$. This we call ${\bf \bar{x}}$
{\bf Note} that $x$ and $\bar{x}$ are coordinates on the same $x$-axis, but represent
different, independent coordinates. This is important, because formally we are using
the DAF method as an operator to transform discrete points $\bf{x}$ into an analytic
funtion on the domain of $\bf{\bar{x}}$. This can be tricky to keep straight, but it
is important because some times we will operate $\bf{x}$ space and sometimes on $\bf{\bar{x}}$. 

From the properties of the $\delta(x)$ function, we can now write an identity for
calculating a single point of $f$ in the domain of $x$ (not $\bar{x}$). 
\begin{equation}
\label{eqn_fdelt_ident}
f(\bar{x}_i) = \int\delta(\bar{x}_i-x)f(x){\rm d}x
\end{equation}

Now, we only know the values of $f$ at the points $x$, so in practice this integral
will be a summation of some form with appropriate weight factors, $w_i$. 
\begin{equation}
\label{eqn_fdelt_sum}
f(\bar{x}_i) = \sum_j w_j \delta(\bar{x}_i-x_j)f(x_j)
\end{equation}

Next, we replace the $\delta$ function with the expansion defined in equation 
\ref{eqn_DeltaExpansion} to get the following...
\begin{eqnarray}
f(\bar{x}_i) &=& \sum_j w_j \delta(\bar{x}_i-x_j)f(x_j) \\
f(\bar{x}_i) &=& \sum_j w_j \Delta_{\sigma,M}\left(\frac{x_i-\bar{x}_j}{\sigma}\right)f(x_j) \\
f_i & = &  \sum_j {\bf D}_{\sigma M,ij} {\bf f}_j
\end{eqnarray}

\begin{figure}
\includegraphics{hdeltas.jpg}
\caption{Delta functions at a given set of $x$ points.}
\label{fig:hdeltas}
\end{figure}

Where we have defined ${\bf D}_{\sigma M, ij}$ as the combination of the integration weights, $w_j$ and 
the $\delta$ function expansion. 
Note that $\sigma$ and $M$ are parameters that are used to tune the DAF method for 
better accuracy, and the indices $i,j$ indicate the points in $x$ and $\bar{x}$ space. 
For simplicity, from here on we drop the $\sigma$ and $M$ specifiers from the notation, 
and define
\begin{equation}
\label{eqn_DAF_def0}
{\bf D}_{ij} = w_j \Delta_{\sigma,M}(x_i-\bar{x}_j) = w_j \sum_{m=0}^M h_m H_m \left(\frac{x_i-\bar{x}_j}{\sigma}\right)e^{- \left(\frac{x_i-\bar{x}_j}{\sigma}\right)^2}
\end{equation}
and we define ${\bf D}_{ij}$ to be the {\it DAF Operator} in one dimension. 

With the DAF operator defined by given parameters of $\sigma$ and $M$, we can see that it 
is indexed by two labels, one for $x$ space and one for $\bar{x}$ space. Since we 
included the integration weights into the definition, we can now write
\begin{equation}
f_j = \sum_i {\bf D}_{ij} f_i
\end{equation}
which is equivalent to a vector-vector multiply, 

\begin{equation}
f_j = \left(D_{0j}, D_{1j}, D_{2,j}, ...\right)
\begin{pmatrix}
f_0\\
f_1\\
f_2\\
...
\end{pmatrix}
\end{equation}


%-----------------------------------------------------------------------------------------
\subsection{Multi-Dimensional}

In a multi-dimensional application, we use the DAF to approximate a function such as
\begin{equation}
f(\bar{x},\bar{y},\bar{z}) = \iiint f(x,y,z)\delta(\bar{x}-x)\delta(\bar{y}-y)\delta(\bar{z}-z) {\rm d}x {\rm d}y {\rm d}z
\end{equation}
or in vector notation for simplicity: 
\begin{equation}
f({\bf \bar{r}}) = \int_{\bf V} f({\bf r})\delta({\bf \bar{r}}-{\bf r}){\rm d}{\bf r}
\end{equation}
where $\delta({\bf r}) = \delta(r_1)\delta(r_2)\delta(r_3)...$ and ${\bf V}$ is the
multi-dimensional volume to which the DAF is being applied. 

In three spacial dimensions, these coordinates are typically x, y, and z, but the method is
not limited to strictly spacial coordinates, nor is it limited to the number of
dimensions. 


%=========================================================================================
\section{ITEMS TO INCLUDE IN TEXT}
{\bf NOTE: Toeplitz Matrices?}

{\bf NOTE: The points at which values or derivatives of the function are wanted must be known
before construction of the DAF matrices. }

{\bf NOTE: Specialized DAF cases: periodic, symmetric. In multidimensional DAF applications, 
it might be good to label them by the irreducible representation.}

\appendix

\include{lobatto_daf}
\include{simpsons_daf}

\bibliographystyle{apsrev}
\bibliography{biblist}

\end{document}
